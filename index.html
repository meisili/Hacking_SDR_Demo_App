<!DOCTYPE html>
<html lang="en">
<head>
    <base target="_top">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Stanford Campus Map - Bonus Step: Filter to Wikidata Features</title>

    <!-- Leaflet CSS for mapping library -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <!-- Leaflet JS for mapping functionality -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <!-- Projection library for geospatial coordinate transformations -->
    <script src="https://unpkg.com/proj4"></script>
    <!-- GeoRaster library for reading raster data -->
    <script src="https://unpkg.com/georaster"></script>
    <!-- GeoRaster Layer plugin for Leaflet to display rasters -->
    <script src="https://unpkg.com/georaster-layer-for-leaflet"></script>
    
    <!-- External CSS file with all styling for the split-screen layout -->
    <link rel="stylesheet" href="styles_wikidata.css">
</head>
<body>

<!-- Page heading -->
<h1>Stanford Public Art Map</h1>
<!-- Step description -->
<p>Bonus Step: Filter the map to only show features that have Wikidata IDs</p>

<!-- Main container divided into two sections: map and info panel -->
<div id="container">
    <!-- Left side: map wrapper contains the Leaflet map -->
    <div id="mapWrapper">
        <div id="map"></div>
    </div>
    <!-- Right side: Wikidata information panel with dynamic content -->
    <div id="wikidata-panel">
        <div id="no-selection">Click on an artwork to see Wikidata information</div>
    </div>
</div>

<script>

    // Initialize the Leaflet map object centered on Stanford campus (lat: 37.427, lon: -122.169) at zoom level 15
    const map = L.map('map').setView([37.427, -122.169], 15);

    // Add OpenStreetMap basemap tiles to the map
    const tiles = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    // Helper function to fetch human-readable label for a Wikidata entity by its ID
    // Used to convert property values (which are Wikidata IDs) into readable names
    async function getWikidataLabel(wikidataId) {
        try {
            // Fetch the Wikidata entity in JSON format from the official Wikidata API
            const response = await fetch(`https://www.wikidata.org/wiki/Special:EntityData/${wikidataId}.json`);
            const data = await response.json();
            const entity = data.entities[wikidataId];
            // Return the English label if available, otherwise return the ID itself
            return entity.labels.en ? entity.labels.en.value : wikidataId;
        } catch (error) {
            // If there's an error fetching the label, just return the ID
            return wikidataId;
        }
    }

    // Helper function to fetch Wikidata image from Wikidata entity
    // Returns the URL to a Wikimedia Commons image if the entity has one, otherwise null
    async function getWikidataImage(wikidataId) {
        try {
            // Fetch the Wikidata entity in JSON format from the official Wikidata API
            const response = await fetch(`https://www.wikidata.org/wiki/Special:EntityData/${wikidataId}.json`);
            const data = await response.json();
            const entity = data.entities[wikidataId];
            
            // Check if the entity has claims (properties) and specifically P18 (image)
            // P18 is the Wikidata property ID for "image"
            if (entity.claims && entity.claims.P18) {
                // Extract the filename from the first image claim
                const filename = entity.claims.P18[0].mainsnak.datavalue.value;
                // URL-encode the filename, replacing spaces with underscores as per Wikimedia convention
                const encodedFilename = encodeURIComponent(filename.replace(/ /g, '_'));
                // Return the full URL to the image hosted on Wikimedia Commons, with width constraint
                return `https://commons.wikimedia.org/wiki/Special:FilePath/${encodedFilename}?width=300`;
            }
        } catch (error) {
            // Log any errors to the browser console for debugging
            console.error('Error fetching image:', error);
        }
        // Return null if no image was found
        return null;
    }

    // Function to fetch and display complete Wikidata content including images and properties
    async function displayWikidataInfo(wikidataId) {
        const panel = document.getElementById('wikidata-panel');
        
        try {
            // Fetch the Wikidata entity in JSON format from the official Wikidata API
            const response = await fetch(`https://www.wikidata.org/wiki/Special:EntityData/${wikidataId}.json`);
            const data = await response.json();
            const entity = data.entities[wikidataId];
            
            // Check if entity was found in the API response
            if (!entity) {
                panel.innerHTML = '<div id="no-selection">Wikidata not found</div>';
                return;
            }
            
            // Begin building the HTML content for the panel
            let html = '<div class="wikidata-content">';
            
            // Extract and display the artwork label (English version, or fallback to ID)
            const label = entity.labels.en ? entity.labels.en.value : wikidataId;
            html += `<div class="wikidata-label">${label}</div>`;
            
            // Extract and display the description (English version) if available
            if (entity.descriptions.en) {
                html += `<div class="wikidata-description">${entity.descriptions.en.value}</div>`;
            }
            
            // Fetch and display the image associated with the artwork if it exists
            const imageUrl = await getWikidataImage(wikidataId);
            if (imageUrl) {
                html += `<img src="${imageUrl}" alt="${label}" class="wikidata-image">`;
            }
            
            // Display additional Wikidata properties/claims if they exist
            if (entity.claims) {
                // P170 is the Wikidata property ID for "artist"
                if (entity.claims.P170) {
                    const artistId = entity.claims.P170[0].mainsnak.datavalue.value.id;
                    // Fetch the human-readable name of the artist
                    const artistName = await getWikidataLabel(artistId);
                    html += `<div class="wikidata-property"><span class="wikidata-property-label">Artist:</span> ${artistName}</div>`;
                }
                
                // P61 is the Wikidata property ID for "creator" (alternative to artist)
                if (entity.claims.P61) {
                    const creatorId = entity.claims.P61[0].mainsnak.datavalue.value.id;
                    // Fetch the human-readable name of the creator
                    const creatorName = await getWikidataLabel(creatorId);
                    html += `<div class="wikidata-property"><span class="wikidata-property-label">Creator:</span> ${creatorName}</div>`;
                }
                
                // P571 is the Wikidata property ID for "inception" (date of creation)
                if (entity.claims.P571) {
                    // Extract the date value (formatted as ISO 8601 timestamp)
                    const date = entity.claims.P571[0].mainsnak.datavalue.value.time;
                    html += `<div class="wikidata-property"><span class="wikidata-property-label">Date:</span> ${date}</div>`;
                }
                
                // P186 is the Wikidata property ID for "material"
                if (entity.claims.P186) {
                    const materialId = entity.claims.P186[0].mainsnak.datavalue.value.id;
                    // Fetch the human-readable name of the material
                    const materialName = await getWikidataLabel(materialId);
                    html += `<div class="wikidata-property"><span class="wikidata-property-label">Material:</span> ${materialName}</div>`;
                }
            }
            
            // Link to view the full Wikidata page in a new tab
            html += `<div class="wikidata-property"><a href="https://www.wikidata.org/wiki/${wikidataId}" target="_blank" class="wikidata-link">View on Wikidata</a></div>`;
            
            // Close the content div and update the panel
            html += '</div>';
            panel.innerHTML = html;
        } catch (error) {
            // Log any errors to the browser console for debugging
            console.error('Error fetching Wikidata:', error);
            // Display an error message in the panel
            panel.innerHTML = '<div id="no-selection">Error loading Wikidata information</div>';
        }
    }

    // Load and display the Cloud Optimized GeoTIFF (COG) raster layer
    var url_to_geotiff_file = new URL("stanford_campus_irg.tif", window.location.href).href;

    // Parse the GeoTIFF file to extract georaster information
    parseGeoraster(url_to_geotiff_file).then(georaster => {
      console.log("georaster:", georaster);

      // Fetch the mask GeoJSON to clip the raster to Stanford campus boundary
      fetch("stanford_campus.geojson")
        .then(r => r.json())
        .then(maskGeojson => {
          // Create a new GeoRaster layer with the parsed data and mask
          var layer = new GeoRasterLayer({
            attribution: "Planet",
            georaster: georaster,
            resolution: 128,
            mask: maskGeojson
          });

          // Add the raster layer to the map and adjust view to fit layer bounds
          layer.addTo(map);
          map.fitBounds(layer.getBounds());
        });
    }).catch(console.error);

    // Load the public art GeoJSON file
    fetch('stanford_public_art.geojson')
        .then(response => response.json())
        .then(data => {
            // Filter to only features that include a wikidata ID
            const filteredFeatures = (data.features || []).filter(feature => {
                const props = feature.properties || {};
                return Boolean(props.wikidata);
            });

            // If nothing remains after filtering, inform the user
            if (filteredFeatures.length === 0) {
                document.getElementById('wikidata-panel').innerHTML = '<div id="no-selection">No artworks with Wikidata IDs were found in the dataset.</div>';
                return;
            }

            // Build a new GeoJSON object with only the filtered features
            const filteredGeojson = {
                type: 'FeatureCollection',
                features: filteredFeatures
            };

            // Create a GeoJSON layer with custom styling and interactivity
            const artworkLayer = L.geoJSON(filteredGeojson, {
                // Custom function to create circle markers instead of default icons
                pointToLayer: function(feature, latlng) {
                    return L.circleMarker(latlng, {
                        radius: 6,
                        color: 'white',
                        weight: 2,
                        fillColor: 'blue',
                        fillOpacity: 0.7
                    });
                },
                // Add popup content and click handlers to each feature
                onEachFeature: function(feature, layer) {
                    const props = feature.properties || {};
                    const title = props.name || 'Artwork';
                    const artist = props.artist_name;
                    const type = props.artwork_type;
                    
                    // Build popup HTML content with artwork information from the GeoJSON
                    let popupContent = '<div style="min-width:200px;">';
                    popupContent += '<b>' + title + '</b><br>';
                    if (artist) popupContent += '<b>Artist:</b> ' + artist + '<br>';
                    if (type) popupContent += '<b>Type:</b> ' + type;
                    popupContent += '</div>';
                    
                    // Bind the popup to the marker so it appears on click
                    layer.bindPopup(popupContent);
                    
                    // Add click handler to display Wikidata info when marker is clicked
                    layer.on('click', function() {
                        // props.wikidata is guaranteed by the filter, but keep a guard
                        if (props.wikidata) {
                            displayWikidataInfo(props.wikidata);
                        } else {
                            document.getElementById('wikidata-panel').innerHTML = '<div id="no-selection">No Wikidata ID available for this artwork</div>';
                        }
                    });
                }
            }).addTo(map);

            // Adjust map zoom and position to display all filtered artwork markers
            if (filteredFeatures.length > 0) {
                map.fitBounds(artworkLayer.getBounds());
            }
        })
        .catch(error => console.error('Error loading GeoJSON:', error));

</script>

</body>
</html>
